"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NavigatorProvider = void 0;
var _react = require("react");
var _element = require("@wordpress/element");
var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));
var _context = require("../../context");
var _useCx = require("../../utils/hooks/use-cx");
var _router = require("../utils/router");
var _view = require("../../view");
var _context2 = require("../context");
var styles = _interopRequireWildcard(require("../styles"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

const MAX_HISTORY_LENGTH = 50;
function addScreen({
  screens
}, screen) {
  return [...screens, screen];
}
function removeScreen({
  screens
}, screen) {
  return screens.filter(s => s.id !== screen.id);
}
function goBack({
  locationHistory
}) {
  if (locationHistory.length <= 1) {
    return locationHistory;
  }
  return [...locationHistory.slice(0, -2), {
    ...locationHistory[locationHistory.length - 2],
    isBack: true,
    hasRestoredFocus: false
  }];
}
function goTo(state, path, options = {}) {
  const {
    locationHistory
  } = state;
  const {
    focusTargetSelector,
    isBack = false,
    skipFocus = false,
    replace = false,
    ...restOptions
  } = options;
  const isNavigatingToPreviousPath = isBack && locationHistory.length > 1 && locationHistory[locationHistory.length - 2].path === path;
  if (isNavigatingToPreviousPath) {
    return goBack(state);
  }
  const newLocation = {
    ...restOptions,
    path,
    isBack,
    hasRestoredFocus: false,
    skipFocus
  };
  if (locationHistory.length === 0) {
    return replace ? [] : [newLocation];
  }
  const newLocationHistory = locationHistory.slice(locationHistory.length > MAX_HISTORY_LENGTH - 1 ? 1 : 0, -1);
  if (!replace) {
    newLocationHistory.push(
    // Assign `focusTargetSelector` to the previous location in history
    // (the one we just navigated from).
    {
      ...locationHistory[locationHistory.length - 1],
      focusTargetSelector
    });
  }
  newLocationHistory.push(newLocation);
  return newLocationHistory;
}
function goToParent(state, options = {}) {
  const {
    locationHistory,
    screens
  } = state;
  const currentPath = locationHistory[locationHistory.length - 1].path;
  if (currentPath === undefined) {
    return locationHistory;
  }
  const parentPath = (0, _router.findParent)(currentPath, screens);
  if (parentPath === undefined) {
    return locationHistory;
  }
  return goTo(state, parentPath, {
    ...options,
    isBack: true
  });
}
function routerReducer(state, action) {
  let {
    screens,
    locationHistory,
    matchedPath
  } = state;
  switch (action.type) {
    case 'add':
      screens = addScreen(state, action.screen);
      break;
    case 'remove':
      screens = removeScreen(state, action.screen);
      break;
    case 'goback':
      locationHistory = goBack(state);
      break;
    case 'goto':
      locationHistory = goTo(state, action.path, action.options);
      break;
    case 'gotoparent':
      locationHistory = goToParent(state, action.options);
      break;
  }

  // Return early in case there is no change
  if (screens === state.screens && locationHistory === state.locationHistory) {
    return state;
  }

  // Compute the matchedPath
  const currentPath = locationHistory.length > 0 ? locationHistory[locationHistory.length - 1].path : undefined;
  matchedPath = currentPath !== undefined ? (0, _router.patternMatch)(currentPath, screens) : undefined;

  // If the new match is the same as the previous match,
  // return the previous one to keep immutability.
  if (matchedPath && state.matchedPath && matchedPath.id === state.matchedPath.id && (0, _isShallowEqual.default)(matchedPath.params, state.matchedPath.params)) {
    matchedPath = state.matchedPath;
  }
  return {
    screens,
    locationHistory,
    matchedPath
  };
}
function UnconnectedNavigatorProvider(props, forwardedRef) {
  const {
    initialPath,
    children,
    className,
    ...otherProps
  } = (0, _context.useContextSystem)(props, 'NavigatorProvider');
  const [routerState, dispatch] = (0, _element.useReducer)(routerReducer, initialPath, path => ({
    screens: [],
    locationHistory: [{
      path
    }],
    matchedPath: undefined
  }));

  // The methods are constant forever, create stable references to them.
  const methods = (0, _element.useMemo)(() => ({
    goBack: () => dispatch({
      type: 'goback'
    }),
    goTo: (path, options) => dispatch({
      type: 'goto',
      path,
      options
    }),
    goToParent: options => dispatch({
      type: 'gotoparent',
      options
    }),
    addScreen: screen => dispatch({
      type: 'add',
      screen
    }),
    removeScreen: screen => dispatch({
      type: 'remove',
      screen
    })
  }), []);
  const {
    locationHistory,
    matchedPath
  } = routerState;
  const navigatorContextValue = (0, _element.useMemo)(() => {
    var _matchedPath$params;
    return {
      location: {
        ...locationHistory[locationHistory.length - 1],
        isInitial: locationHistory.length === 1
      },
      params: (_matchedPath$params = matchedPath?.params) !== null && _matchedPath$params !== void 0 ? _matchedPath$params : {},
      match: matchedPath?.id,
      ...methods
    };
  }, [locationHistory, matchedPath, methods]);
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)(() => cx(styles.navigatorProviderWrapper, className), [className, cx]);
  return (0, _react.createElement)(_view.View, {
    ref: forwardedRef,
    className: classes,
    ...otherProps
  }, (0, _react.createElement)(_context2.NavigatorContext.Provider, {
    value: navigatorContextValue
  }, children));
}

/**
 * The `NavigatorProvider` component allows rendering nested views/panels/menus
 * (via the `NavigatorScreen` component and navigate between these different
 * view (via the `NavigatorButton` and `NavigatorBackButton` components or the
 * `useNavigator` hook).
 *
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorProvider = exports.NavigatorProvider = (0, _context.contextConnect)(UnconnectedNavigatorProvider, 'NavigatorProvider');
var _default = exports.default = NavigatorProvider;
//# sourceMappingURL=component.js.map