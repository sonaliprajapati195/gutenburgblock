"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.childLayoutOrientation = childLayoutOrientation;
exports.default = ChildLayoutControl;
var _react = require("react");
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
/**
 * WordPress dependencies
 */

function helpText(selfStretch, parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  if (selfStretch === 'fill') {
    return (0, _i18n.__)('Stretch to fill available space.');
  }
  if (selfStretch === 'fixed' && orientation === 'horizontal') {
    return (0, _i18n.__)('Specify a fixed width.');
  } else if (selfStretch === 'fixed') {
    return (0, _i18n.__)('Specify a fixed height.');
  }
  return (0, _i18n.__)('Fit contents.');
}

/**
 * Form to edit the child layout value.
 *
 * @param {Object}   props                  Props.
 * @param {Object}   props.value            The child layout value.
 * @param {Function} props.onChange         Function to update the child layout value.
 * @param {Object}   props.parentLayout     The parent layout value.
 *
 * @param {boolean}  props.isShownByDefault
 * @param {string}   props.panelId
 * @return {Element} child layout edit element.
 */
function ChildLayoutControl({
  value: childLayout = {},
  onChange,
  parentLayout,
  isShownByDefault,
  panelId
}) {
  const {
    selfStretch,
    flexSize,
    columnStart,
    rowStart,
    columnSpan,
    rowSpan
  } = childLayout;
  const {
    type: parentType,
    default: {
      type: defaultParentType = 'default'
    } = {},
    orientation = 'horizontal'
  } = parentLayout !== null && parentLayout !== void 0 ? parentLayout : {};
  const parentLayoutType = parentType || defaultParentType;
  const hasFlexValue = () => !!selfStretch;
  const flexResetLabel = orientation === 'horizontal' ? (0, _i18n.__)('Width') : (0, _i18n.__)('Height');
  const resetFlex = () => {
    onChange({
      selfStretch: undefined,
      flexSize: undefined
    });
  };
  const hasStartValue = () => !!columnStart || !!rowStart;
  const hasSpanValue = () => !!columnSpan || !!rowSpan;
  const resetGridStarts = () => {
    onChange({
      columnStart: undefined,
      rowStart: undefined
    });
  };
  const resetGridSpans = () => {
    onChange({
      columnSpan: undefined,
      rowSpan: undefined
    });
  };
  (0, _element.useEffect)(() => {
    if (selfStretch === 'fixed' && !flexSize) {
      onChange({
        ...childLayout,
        selfStretch: 'fit'
      });
    }
  }, []);
  return (0, _react.createElement)(_react.Fragment, null, parentLayoutType === 'flex' && (0, _react.createElement)(_components.__experimentalVStack, {
    as: _components.__experimentalToolsPanelItem,
    spacing: 2,
    hasValue: hasFlexValue,
    label: flexResetLabel,
    onDeselect: resetFlex,
    isShownByDefault: isShownByDefault,
    panelId: panelId
  }, (0, _react.createElement)(_components.__experimentalToggleGroupControl, {
    __nextHasNoMarginBottom: true,
    size: '__unstable-large',
    label: childLayoutOrientation(parentLayout),
    value: selfStretch || 'fit',
    help: helpText(selfStretch, parentLayout),
    onChange: value => {
      const newFlexSize = value !== 'fixed' ? null : flexSize;
      onChange({
        selfStretch: value,
        flexSize: newFlexSize
      });
    },
    isBlock: true
  }, (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fit',
    value: 'fit',
    label: (0, _i18n.__)('Fit')
  }), (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fill',
    value: 'fill',
    label: (0, _i18n.__)('Fill')
  }), (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fixed',
    value: 'fixed',
    label: (0, _i18n.__)('Fixed')
  })), selfStretch === 'fixed' && (0, _react.createElement)(_components.__experimentalUnitControl, {
    size: '__unstable-large',
    onChange: value => {
      onChange({
        selfStretch,
        flexSize: value
      });
    },
    value: flexSize
  })), parentLayoutType === 'grid' && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.__experimentalHStack, {
    as: _components.__experimentalToolsPanelItem,
    hasValue: hasSpanValue,
    label: (0, _i18n.__)('Grid span'),
    onDeselect: resetGridSpans,
    isShownByDefault: isShownByDefault,
    panelId: panelId
  }, (0, _react.createElement)(_components.__experimentalInputControl, {
    size: '__unstable-large',
    label: (0, _i18n.__)('Column span'),
    type: "number",
    onChange: value => {
      onChange({
        columnStart,
        rowStart,
        rowSpan,
        columnSpan: value
      });
    },
    value: columnSpan,
    min: 1
  }), (0, _react.createElement)(_components.__experimentalInputControl, {
    size: '__unstable-large',
    label: (0, _i18n.__)('Row span'),
    type: "number",
    onChange: value => {
      onChange({
        columnStart,
        rowStart,
        columnSpan,
        rowSpan: value
      });
    },
    value: rowSpan,
    min: 1
  })), window.__experimentalEnableGridInteractivity &&
  // Use Flex with an explicit width on the FlexItem instead of HStack to
  // work around an issue in webkit where inputs with a max attribute are
  // sized incorrectly.
  (0, _react.createElement)(_components.Flex, {
    as: _components.__experimentalToolsPanelItem,
    hasValue: hasStartValue,
    label: (0, _i18n.__)('Grid placement'),
    onDeselect: resetGridStarts,
    isShownByDefault: false,
    panelId: panelId
  }, (0, _react.createElement)(_components.FlexItem, {
    style: {
      width: '50%'
    }
  }, (0, _react.createElement)(_components.__experimentalInputControl, {
    size: '__unstable-large',
    label: (0, _i18n.__)('Column'),
    type: "number",
    onChange: value => {
      onChange({
        columnStart: value,
        rowStart,
        columnSpan,
        rowSpan
      });
    },
    value: columnStart,
    min: 1,
    max: parentLayout?.columnCount
  })), (0, _react.createElement)(_components.FlexItem, {
    style: {
      width: '50%'
    }
  }, (0, _react.createElement)(_components.__experimentalInputControl, {
    size: '__unstable-large',
    label: (0, _i18n.__)('Row'),
    type: "number",
    onChange: value => {
      onChange({
        columnStart,
        rowStart: value,
        columnSpan,
        rowSpan
      });
    },
    value: rowStart,
    min: 1,
    max: parentLayout?.columnCount
  })))));
}
function childLayoutOrientation(parentLayout) {
  const {
    orientation = 'horizontal'
  } = parentLayout;
  return orientation === 'horizontal' ? (0, _i18n.__)('Width') : (0, _i18n.__)('Height');
}
//# sourceMappingURL=index.js.map