"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.coordsToBackgroundPosition = exports.backgroundPositionToCoords = void 0;
exports.default = BackgroundPanel;
exports.hasBackgroundImageValue = hasBackgroundImageValue;
exports.hasBackgroundSizeValue = hasBackgroundSizeValue;
exports.useHasBackgroundPanel = useHasBackgroundPanel;
var _react = require("react");
var _classnames = _interopRequireDefault(require("classnames"));
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _notices = require("@wordpress/notices");
var _url = require("@wordpress/url");
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _dom = require("@wordpress/dom");
var _blob = require("@wordpress/blob");
var _utils = require("./utils");
var _object = require("../../utils/object");
var _mediaReplaceFlow = _interopRequireDefault(require("../media-replace-flow"));
var _store = require("../../store");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const IMAGE_BACKGROUND_TYPE = 'image';

/**
 * Checks site settings to see if the background panel may be used.
 * `settings.background.backgroundSize` exists also,
 * but can only be used if settings?.background?.backgroundImage is `true`.
 *
 * @param {Object} settings Site settings
 * @return {boolean}        Whether site settings has activated background panel.
 */
function useHasBackgroundPanel(settings) {
  return _element.Platform.OS === 'web' && settings?.background?.backgroundImage;
}

/**
 * Checks if there is a current value in the background size block support
 * attributes. Background size values include background size as well
 * as background position.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background size value set.
 */
function hasBackgroundSizeValue(style) {
  return style?.background?.backgroundPosition !== undefined || style?.background?.backgroundSize !== undefined;
}

/**
 * Checks if there is a current value in the background image block support
 * attributes.
 *
 * @param {Object} style Style attribute.
 * @return {boolean}     Whether the block has a background image value set.
 */
function hasBackgroundImageValue(style) {
  return !!style?.background?.backgroundImage?.id || !!style?.background?.backgroundImage?.url;
}

/**
 * Get the help text for the background size control.
 *
 * @param {string} value backgroundSize value.
 * @return {string}      Translated help text.
 */
function backgroundSizeHelpText(value) {
  if (value === 'cover' || value === undefined) {
    return (0, _i18n.__)('Image covers the space evenly.');
  }
  if (value === 'contain') {
    return (0, _i18n.__)('Image is contained without distortion.');
  }
  return (0, _i18n.__)('Specify a fixed width.');
}

/**
 * Converts decimal x and y coords from FocalPointPicker to percentage-based values
 * to use as backgroundPosition value.
 *
 * @param {{x?:number, y?:number}} value FocalPointPicker coords.
 * @return {string}      				 backgroundPosition value.
 */
const coordsToBackgroundPosition = value => {
  if (!value || isNaN(value.x) && isNaN(value.y)) {
    return undefined;
  }
  const x = isNaN(value.x) ? 0.5 : value.x;
  const y = isNaN(value.y) ? 0.5 : value.y;
  return `${x * 100}% ${y * 100}%`;
};

/**
 * Converts backgroundPosition value to x and y coords for FocalPointPicker.
 *
 * @param {string} value backgroundPosition value.
 * @return {{x?:number, y?:number}}       FocalPointPicker coords.
 */
exports.coordsToBackgroundPosition = coordsToBackgroundPosition;
const backgroundPositionToCoords = value => {
  if (!value) {
    return {
      x: undefined,
      y: undefined
    };
  }
  let [x, y] = value.split(' ').map(v => parseFloat(v) / 100);
  x = isNaN(x) ? undefined : x;
  y = isNaN(y) ? x : y;
  return {
    x,
    y
  };
};
exports.backgroundPositionToCoords = backgroundPositionToCoords;
function InspectorImagePreview({
  label,
  filename,
  url: imgUrl
}) {
  const imgLabel = label || (0, _url.getFilename)(imgUrl);
  return (0, _react.createElement)(_components.__experimentalItemGroup, {
    as: "span"
  }, (0, _react.createElement)(_components.__experimentalHStack, {
    justify: "flex-start",
    as: "span"
  }, (0, _react.createElement)("span", {
    className: (0, _classnames.default)('block-editor-global-styles-background-panel__inspector-image-indicator-wrapper', {
      'has-image': imgUrl
    }),
    "aria-hidden": true
  }, imgUrl && (0, _react.createElement)("span", {
    className: "block-editor-global-styles-background-panel__inspector-image-indicator",
    style: {
      backgroundImage: `url(${imgUrl})`
    }
  })), (0, _react.createElement)(_components.FlexItem, {
    as: "span"
  }, (0, _react.createElement)(_components.__experimentalTruncate, {
    numberOfLines: 1,
    className: "block-editor-global-styles-background-panel__inspector-media-replace-title"
  }, imgLabel), (0, _react.createElement)(_components.VisuallyHidden, {
    as: "span"
  }, filename ? (0, _i18n.sprintf)( /* translators: %s: file name */
  (0, _i18n.__)('Selected image: %s'), filename) : (0, _i18n.__)('No image selected')))));
}
function BackgroundImageToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue
}) {
  const mediaUpload = (0, _data.useSelect)(select => select(_store.store).getSettings().mediaUpload, []);
  const {
    id,
    title,
    url
  } = style?.background?.backgroundImage || {
    ...inheritedValue?.background?.backgroundImage
  };
  const replaceContainerRef = (0, _element.useRef)();
  const {
    createErrorNotice
  } = (0, _data.useDispatch)(_notices.store);
  const onUploadError = message => {
    createErrorNotice(message, {
      type: 'snackbar'
    });
  };
  const resetBackgroundImage = () => onChange((0, _object.setImmutably)(style, ['background', 'backgroundImage'], undefined));
  const onSelectMedia = media => {
    if (!media || !media.url) {
      resetBackgroundImage();
      return;
    }
    if ((0, _blob.isBlobURL)(media.url)) {
      return;
    }

    // For media selections originated from a file upload.
    if (media.media_type && media.media_type !== IMAGE_BACKGROUND_TYPE || !media.media_type && media.type && media.type !== IMAGE_BACKGROUND_TYPE) {
      onUploadError((0, _i18n.__)('Only images can be used as a background image.'));
      return;
    }
    onChange((0, _object.setImmutably)(style, ['background', 'backgroundImage'], {
      url: media.url,
      id: media.id,
      source: 'file',
      title: media.title || undefined
    }));
  };
  const onFilesDrop = filesList => {
    mediaUpload({
      allowedTypes: ['image'],
      filesList,
      onFileChange([image]) {
        if ((0, _blob.isBlobURL)(image?.url)) {
          return;
        }
        onSelectMedia(image);
      },
      onError: onUploadError
    });
  };
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: undefined
      }
    };
  }, []);
  const hasValue = hasBackgroundImageValue(style) || hasBackgroundImageValue(inheritedValue);
  return (0, _react.createElement)(_components.__experimentalToolsPanelItem, {
    className: "single-column",
    hasValue: () => hasValue,
    label: (0, _i18n.__)('Background image'),
    onDeselect: resetBackgroundImage,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId
  }, (0, _react.createElement)("div", {
    className: "block-editor-global-styles-background-panel__inspector-media-replace-container",
    ref: replaceContainerRef
  }, (0, _react.createElement)(_mediaReplaceFlow.default, {
    mediaId: id,
    mediaURL: url,
    allowedTypes: [IMAGE_BACKGROUND_TYPE],
    accept: "image/*",
    onSelect: onSelectMedia,
    name: (0, _react.createElement)(InspectorImagePreview, {
      label: (0, _i18n.__)('Background image'),
      filename: title || (0, _i18n.__)('Untitled'),
      url: url
    }),
    variant: "secondary"
  }, hasValue && (0, _react.createElement)(_components.MenuItem, {
    onClick: () => {
      const [toggleButton] = _dom.focus.tabbable.find(replaceContainerRef.current);
      // Focus the toggle button and close the dropdown menu.
      // This ensures similar behaviour as to selecting an image, where the dropdown is
      // closed and focus is redirected to the dropdown toggle button.
      toggleButton?.focus();
      toggleButton?.click();
      resetBackgroundImage();
    }
  }, (0, _i18n.__)('Reset '))), (0, _react.createElement)(_components.DropZone, {
    onFilesDrop: onFilesDrop,
    label: (0, _i18n.__)('Drop to upload')
  })));
}
function BackgroundSizeToolsPanelItem({
  panelId,
  isShownByDefault,
  onChange,
  style,
  inheritedValue,
  defaultValues
}) {
  const sizeValue = style?.background?.backgroundSize || inheritedValue?.background?.backgroundSize;
  const repeatValue = style?.background?.backgroundRepeat || inheritedValue?.background?.backgroundRepeat;
  const imageValue = style?.background?.backgroundImage?.url || inheritedValue?.background?.backgroundImage?.url;
  const positionValue = style?.background?.backgroundPosition || inheritedValue?.background?.backgroundPosition;

  /*
   * An `undefined` value is replaced with any supplied
   * default control value for the toggle group control.
   * An empty string is treated as `auto` - this allows a user
   * to select "Size" and then enter a custom value, with an
   * empty value being treated as `auto`.
   */
  const currentValueForToggle = sizeValue !== undefined && sizeValue !== 'cover' && sizeValue !== 'contain' || sizeValue === '' ? 'auto' : sizeValue || defaultValues?.backgroundSize;

  /*
   * If the current value is `cover` and the repeat value is `undefined`, then
   * the toggle should be unchecked as the default state. Otherwise, the toggle
   * should reflect the current repeat value.
   */
  const repeatCheckedValue = !(repeatValue === 'no-repeat' || currentValueForToggle === 'cover' && repeatValue === undefined);
  const hasValue = hasBackgroundSizeValue(style);
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      style: {
        ...previousValue.style,
        background: {
          ...previousValue.style?.background,
          backgroundRepeat: undefined,
          backgroundSize: undefined
        }
      }
    };
  }, []);
  const updateBackgroundSize = next => {
    // When switching to 'contain' toggle the repeat off.
    let nextRepeat = repeatValue;
    if (next === 'contain') {
      nextRepeat = 'no-repeat';
    }
    if (next === 'cover') {
      nextRepeat = undefined;
    }
    if ((currentValueForToggle === 'cover' || currentValueForToggle === 'contain') && next === 'auto') {
      nextRepeat = undefined;
    }
    onChange((0, _object.setImmutably)(style, ['background'], {
      ...style?.background,
      backgroundRepeat: nextRepeat,
      backgroundSize: next
    }));
  };
  const updateBackgroundPosition = next => {
    onChange((0, _object.setImmutably)(style, ['background', 'backgroundPosition'], coordsToBackgroundPosition(next)));
  };
  const toggleIsRepeated = () => onChange((0, _object.setImmutably)(style, ['background', 'backgroundRepeat'], repeatCheckedValue === true ? 'no-repeat' : undefined));
  const resetBackgroundSize = () => onChange((0, _object.setImmutably)(style, ['background'], {
    ...style?.background,
    backgroundPosition: undefined,
    backgroundRepeat: undefined,
    backgroundSize: undefined
  }));
  return (0, _react.createElement)(_components.__experimentalVStack, {
    as: _components.__experimentalToolsPanelItem,
    spacing: 2,
    className: "single-column",
    hasValue: () => hasValue,
    label: (0, _i18n.__)('Size'),
    onDeselect: resetBackgroundSize,
    isShownByDefault: isShownByDefault,
    resetAllFilter: resetAllFilter,
    panelId: panelId
  }, (0, _react.createElement)(_components.FocalPointPicker, {
    __next40pxDefaultSize: true,
    label: (0, _i18n.__)('Position'),
    url: imageValue,
    value: backgroundPositionToCoords(positionValue),
    onChange: updateBackgroundPosition
  }), (0, _react.createElement)(_components.__experimentalToggleGroupControl, {
    size: '__unstable-large',
    label: (0, _i18n.__)('Size'),
    value: currentValueForToggle,
    onChange: updateBackgroundSize,
    isBlock: true,
    help: backgroundSizeHelpText(sizeValue)
  }, (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'cover',
    value: 'cover',
    label: (0, _i18n.__)('Cover')
  }), (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'contain',
    value: 'contain',
    label: (0, _i18n.__)('Contain')
  }), (0, _react.createElement)(_components.__experimentalToggleGroupControlOption, {
    key: 'fixed',
    value: 'auto',
    label: (0, _i18n.__)('Fixed')
  })), sizeValue !== undefined && sizeValue !== 'cover' && sizeValue !== 'contain' ? (0, _react.createElement)(_components.__experimentalUnitControl, {
    size: '__unstable-large',
    onChange: updateBackgroundSize,
    value: sizeValue
  }) : null, currentValueForToggle !== 'cover' && (0, _react.createElement)(_components.ToggleControl, {
    label: (0, _i18n.__)('Repeat'),
    checked: repeatCheckedValue,
    onChange: toggleIsRepeated
  }));
}
function BackgroundToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return (0, _react.createElement)(_components.__experimentalVStack, {
    as: _components.__experimentalToolsPanel,
    spacing: 6,
    label: (0, _i18n.__)('Background'),
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: _utils.TOOLSPANEL_DROPDOWNMENU_PROPS
  }, children);
}
const DEFAULT_CONTROLS = {
  backgroundImage: true,
  backgroundSize: true
};
function BackgroundPanel({
  as: Wrapper = BackgroundToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  defaultControls = DEFAULT_CONTROLS,
  defaultValues = {}
}) {
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      background: {}
    };
  }, []);
  const shouldShowBackgroundSizeControls = settings?.background?.backgroundSize;
  return (0, _react.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId
  }, (0, _react.createElement)(BackgroundImageToolsPanelItem, {
    onChange: onChange,
    panelId: panelId,
    isShownByDefault: defaultControls.backgroundImage,
    style: value,
    inheritedValue: inheritedValue
  }), shouldShowBackgroundSizeControls && (0, _react.createElement)(BackgroundSizeToolsPanelItem, {
    onChange: onChange,
    panelId: panelId,
    isShownByDefault: defaultControls.backgroundSize,
    style: value,
    inheritedValue: inheritedValue,
    defaultValues: defaultValues
  }));
}
//# sourceMappingURL=background-panel.js.map